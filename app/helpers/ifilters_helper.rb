include DocumentsHelper

module IfiltersHelper
  def get_ifiltered_row(f, row)
    retval = []

    if (f == nil or row == nil)
      log_and_print "WARN: ifilter or row was nil during parsing"
      return row
    end
    
    t = row
    if (t.is_a? Array or t.is_a? Hash)
      t = t.join(' ')
    end

    matches = /#{f.regex}/.match(t)

    #if regex finds matches, populate 
    if matches != nil
      matches.captures.each do |mtext|
        retval << mtext
      end
    end
    
    return retval
  end

  
  def get_ifiltered_header(h, row)
    retval = []
    
    if row.is_a? Array
      row = row.join(' ')
    end

    matches = /#{h["val"]}/.match(row)
    if matches != nil
      matches.captures.each do |mtext|
        retval << mtext
      end
    end
    
    return retval
  end

  
  #Returns a autogenerated list of colnames, based on column number
  # i.e. [1,2,3...]
  def get_ifiltered_colnames(row)
    return (1..row.count).to_a
  end

  
  def get_ifilter_headers(ifilter)
    retval = []
    begin
      if ifilter.stuffing_headers != nil
        retval = ifilter.stuffing_headers
      end
    rescue
      retval = []
    end
    
    return retval
  end


  def get_internal_ifilters
    retval = []

    f = Ifilter.new( #new but don't save
                    :name => "CSV (pre-defined)",
                    :regex=> nil
                  )
      #TODO: id
    f.id = -1 #we don't want to stomp on an valid id

    retval.prepend(f)
  end


  #Gets internal and user defined ifilters
  def get_ifilters
    retval = Ifilter.all
    get_internal_ifilters.each do |f|
      retval.prepend(f)
    end

    return retval
  end


  def get_ifilter(id)
    retval = Ifilter.where(:id => id).first

    if (retval == nil or retval.empty?)
      retval = nil
      get_internal_ifilters.collect do |f|
        if f.id == id 
         retval = f
        end
      end
    end

    return retval
  end


  def ifilters_get_select_options
    get_ifilters.collect {|ifilter| [ ifilter.name, ifilter.id ] }
  end
end
